# -*- coding: utf-8 -*-
"""ML Final Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14YCjZr8-zY3wYN0L50lYIkMuNL2a8o4E
"""

# ============================================
# ðŸ“ˆ STOCK MARKET PRICE PREDICTION (APPLE INC.)
# Classic ML (No Deep Learning) - Colab Ready (Final Enhanced)
# ============================================

# ---- 0) Imports
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

# ---- 1) Load data
CSV_PATH = "/content/AAPL.csv"
if not os.path.exists(CSV_PATH):
    raise FileNotFoundError(f"Please upload AAPL.csv to Colab at {CSV_PATH}.")

df = pd.read_csv(CSV_PATH)

# ---- 2) Data insights
print("===== DATA INSIGHTS =====")
print(f"Shape: {df.shape}")
print("Columns:", list(df.columns))
print("\nInfo:")
print(df.info())
print("\nHead:")
print(df.head())

if "Date" not in df.columns:
    raise ValueError("The dataset must have a 'Date' column.")
df["Date"] = pd.to_datetime(df["Date"], errors="coerce")
df = df.sort_values("Date").dropna().reset_index(drop=True)

print("\nSummary statistics:")
print(df.describe().T)
print(f"\nDate range: {df['Date'].min().date()} â†’ {df['Date'].max().date()}")

num_cols = [c for c in ["Open","High","Low","Close","Adj Close","Volume"] if c in df.columns]
plt.figure(figsize=(6,4))
sns.heatmap(df[num_cols].corr(), annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.tight_layout()
plt.show()

# ---- 3) Feature / Target selection
feature_cols = [c for c in ["Open","High","Low","Volume"] if c in df.columns]
target_col = "Close"
X = df[feature_cols].copy()
y = df[target_col].copy()

# ---- 4) Train / Test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# ---- 5) Build model pipelines
svr_pipe = Pipeline([("scaler", StandardScaler()), ("model", SVR(kernel="rbf"))])
linreg_pipe = Pipeline([("scaler", StandardScaler()), ("model", LinearRegression())])
dt_pipe = Pipeline([("model", DecisionTreeRegressor(random_state=42))])
rf_pipe = Pipeline([("model", RandomForestRegressor(n_estimators=200, random_state=42))])

models = {
    "Linear Regression": linreg_pipe,
    "Decision Tree": dt_pipe,
    "Random Forest": rf_pipe,
    "SVR (RBF)": svr_pipe
}

# ---- 6) Train, evaluate all models
def evaluate_regression(y_true, y_pred):
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    mae  = mean_absolute_error(y_true, y_pred)
    r2   = r2_score(y_true, y_pred)
    return mse, rmse, mae, r2

results, fitted_models = [], {}

for name, pipe in models.items():
    pipe.fit(X_train, y_train)
    fitted_models[name] = pipe
    y_pred = pipe.predict(X_test)
    mse, rmse, mae, r2 = evaluate_regression(y_test, y_pred)
    results.append({"Model": name, "MSE": mse, "RMSE": rmse, "MAE": mae, "RÂ²": r2})

results_df = pd.DataFrame(results).sort_values(by="RÂ²", ascending=False).reset_index(drop=True)
print("\n===== MODEL PERFORMANCE COMPARISON =====")
display(results_df.style.format({"MSE":"{:.6f}", "RMSE":"{:.6f}", "MAE":"{:.6f}", "RÂ²":"{:.6f}"}))

# ---- 7) Best Model
best_row = results_df.iloc[0]
best_name = best_row["Model"]
best_model = fitted_models[best_name]

reason_map = {
    "Random Forest": "Random Forest reduces overfitting by averaging many trees, capturing non-linear relationships.",
    "Decision Tree": "Decision Tree handles non-linear patterns well but can overfit if not pruned.",
    "Linear Regression": "Linear Regression assumes linear relation â€” simple and fast but less flexible.",
    "SVR (RBF)": "SVR models complex curves and performs well for moderate data sizes."
}

print(f"\n===== BEST MODEL =====")
print(f"Best Model : {best_name}")
print(f"MSE        : {best_row['MSE']:.6f}")
print(f"RMSE       : {best_row['RMSE']:.6f}")
print(f"MAE        : {best_row['MAE']:.6f}")
print(f"RÂ²         : {best_row['RÂ²']:.6f}")
print(f"Why        : {reason_map.get(best_name.split(' (')[0], 'Best RÂ² and lowest errors among tested models.')}")

# ---- 8) Actual vs Predicted Plot
y_pred_best = best_model.predict(X_test)
plt.figure(figsize=(10,5))
plt.plot(range(len(y_test)), y_test.values, label="Actual", linewidth=2)
plt.plot(range(len(y_pred_best)), y_pred_best, label=f"Predicted ({best_name})", linestyle="--")
plt.title(f"Actual vs Predicted Closing Prices â€” {best_name}")
plt.xlabel("Test Sample Index (time-ordered)")
plt.ylabel("Close Price ($)")
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# ---- 9) Metrics Table
print("\n===== EVALUATION METRICS (ALL MODELS) =====")
display(results_df.rename(columns={"RÂ²":"R2"}).style.format({"MSE":"{:.6f}", "RMSE":"{:.6f}", "MAE":"{:.6f}", "R2":"{:.6f}"}))

# ---- 10) Interactive Prediction
print("\n===== NEXT-DAY CLOSE PREDICTION (INTERACTIVE) =====")
from IPython.display import HTML, display, clear_output
import ipywidgets as widgets

last_vals = df.iloc[-1][feature_cols]
label_map = {
    "Open": "Enter Open Value ($):",
    "High": "Enter High Value ($):",
    "Low": "Enter Low Value ($):",
    "Volume": "Enter Volume (No. of Shares):"
}
inputs = {col: widgets.FloatText(value=float(last_vals[col]),
                                 description=label_map[col],
                                 style={'description_width': '200px'},
                                 layout=widgets.Layout(width='400px')) for col in feature_cols}

predict_button = widgets.Button(description='ðŸ”® Predict', button_style='success', layout=widgets.Layout(width='140px'))
reset_button = widgets.Button(description='â†» Try Again', button_style='info', layout=widgets.Layout(width='140px'))
output_box = widgets.Output()

def predict_stock(_):
    with output_box:
        clear_output()
        input_values = [inputs[col].value for col in feature_cols]
        next_X = np.array(input_values).reshape(1, -1)
        next_close_pred = best_model.predict(next_X)[0]
        r2_value = best_row['RÂ²']

        # Dynamic color based on accuracy
        if r2_value >= 0.9:
            border_color, glow_color, header_color = "#4CAF50", "#A5D6A7", "#2E7D32"
        elif r2_value >= 0.7:
            border_color, glow_color, header_color = "#FFC107", "#FFF59D", "#F57F17"
        else:
            border_color, glow_color, header_color = "#F44336", "#FFCDD2", "#B71C1C"

        display(HTML(f"""
        <style>
        @keyframes glow {{
          0% {{ box-shadow: 0 0 8px {glow_color}; }}
          50% {{ box-shadow: 0 0 18px {border_color}; }}
          100% {{ box-shadow: 0 0 8px {glow_color}; }}
        }}
        </style>

        <div style="
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            border:2px solid {border_color};
            border-radius:14px;
            padding:24px;
            margin-top:15px;
            background:linear-gradient(145deg, #ffffff, #f6fff8);
            color:#000;
            font-size:18px;
            width:fit-content;
            text-align:center;
            animation:glow 2s infinite;
            box-shadow:0 3px 10px rgba(0,0,0,0.1);
        ">
          <div style="font-size:22px; font-weight:700; color:{header_color}; margin-bottom:10px;">
            ðŸ”® Predicted NEXT-Day Closing Price
          </div>
          <div style="font-size:30px; font-weight:bold; color:#1A237E; margin-bottom:10px;">
            ${next_close_pred:.2f}
          </div>
          <div style="font-size:15px; color:#333;">
            <b>Model Used:</b> {best_name}<br>
            <b>RÂ² Score (Accuracy):</b> {r2_value:.4f}
          </div>
        </div>
        """))

def reset_inputs(_):
    with output_box:
        clear_output()
    for col in feature_cols:
        inputs[col].value = float(last_vals[col])

predict_button.on_click(predict_stock)
reset_button.on_click(reset_inputs)

form = widgets.VBox([
    widgets.HTML("<h4 style='color:#2e7d32;'>Enter values for the NEXT trading day:</h4>"),
    inputs['Open'], inputs['High'], inputs['Low'], inputs['Volume'],
    widgets.HBox([predict_button, reset_button]),
    output_box
])
display(form)

# ---- 11) Final Summary
print("\n===== FINAL SUMMARY =====")
print(f"Compared Models : {', '.join(models.keys())}")
print(f"Best Model      : {best_name}")
print(f"Why Best        : {reason_map.get(best_name.split(' (')[0], 'Best RÂ² and lowest errors among tested models')}")
print(f"Metrics (Best)  : MSE={best_row['MSE']:.6f}, RMSE={best_row['RMSE']:.6f}, MAE={best_row['MAE']:.6f}, RÂ²={best_row['RÂ²']:.6f}")
print(f"ðŸŽ¯ Model Accuracy (RÂ² Score)        : {best_row['RÂ²']:.4f}")